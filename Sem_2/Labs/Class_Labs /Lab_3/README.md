# Лабораторная работа  No3 
# Классы и объекты. Перегрузка операций. 

## (1) Задание
1.  Определить пользовательский класс.  
2.  Определить в классе следующие конструкторы: без параметров, с параметрами, копирования.  
3.  Определить в классе деструктор. 
4.  Определить в классе компоненты-функции для просмотра и установки полей данных (селекторы и модификаторы). 
5.  Перегрузить операцию присваивания. 
6.  Перегрузить операции ввода и вывода объектов с помощью потоков. 
7.  Перегрузить операции указанные в варианте. 
8.  Написать программу, в которой продемонстрировать создание объектов и работу всех перегруженных операций.
## Вариант 1
Создать класс Time для работы с временными интервалами. Интервал должен быть представлен в виде двух полей: минуты типа int и секунды типа int. при выводе минуты отделяются от секунд двоеточием. Реализовать: 
  -  сложение временных интервалов (учесть, что в минуте не может быть более 60 секунд) 
  -  сравнение временных интервалов (==) 
## (2) Реализация 
- приколюшная main функция:
```cpp
#include "Time.h" 
#include <iostream> 
using namespace std;
int main()
{
	system("chcp 1251 > Null");
	Time a;
	Time b;
	Time c;
	cout << "Введите значения первой временной точки:" << endl;
	cin >> a;
	cout << "Введите значения второй временной точки:" << endl;
	cin >> b;
	c = a + b;
	cout << "Первый временной интервал: " << a << endl;
	cout << "Вторая временной интервал: " << b << endl;
	cout << "Сумма временных интервалов : " << c << endl;
	if (a.get_min() == b.get_min() && a.get_sec() == b.get_sec())
	{
		cout << "Временные интервалы равны" << endl;
	}
	else
	{
		cout << "! Временные интервалы не равны !" << endl;
	}
	return 0;
}
```
- Time.cpp
```cpp
#include "Time.h" 
#include <iostream> 
using namespace std;
Time& Time::operator=(const Time& t)
{
	if (&t == this) return *this;
	min = t.min;
	sec = t.sec;
	return *this;
}
Time& Time::operator++()
{
	int temp = min * 60 + sec;
	temp++;
	min = temp / 60;
	sec = temp % 60;
	return *this;
}
Time Time::operator ++(int)
{
	int temp = min * 60 + sec;
	temp++;
	Time t(min, sec);
	min = temp / 60;
	sec = temp % 60;
	return t;
}
Time Time::operator+(const Time& t)
{
	int temp1 = min * 60 + sec;
	int temp2 = t.min * 60 + t.sec;
	Time p;
	p.min = (temp1 + temp2) / 60;
	p.sec = (temp1 + temp2) % 60;
	return p;
}
istream& operator>>(istream& in, Time& t)
{
	cout << "Минуты:  "; in >> t.min;
	cout << "Секунды: "; in >> t.sec;
	return in;
}
ostream& operator<<(ostream& out, const Time& t)
{

	return (out << t.min << " : " << t.sec);
}
```
- Time.h
```cpp
#pragma once

#include <iostream> 
using namespace std;

class Time
{
	int min, sec;
public:
	Time() 
	{
		min = 0; sec = 0; 
	};
	Time(int m, int s) 
	{ 
		min = m; sec = s; 
	}
	Time(const Time& t) 
	{ 
		min = t.min; sec = t.sec; 
	}
	~Time() {};

	int get_min()
	{ 
		return min; 
	}
	int get_sec() 
	{
		return sec; 
	}
	void set_min(int m) 
	{ 
		min = m; 
	}
	void set_sec(int s) 
	{
		sec = s; 
	}
	Time& operator=(const Time&);
	Time& operator++();
	Time operator++(int); 
	Time operator+(const Time&);
	friend istream& operator>>(istream& in, Time& t);
	friend ostream& operator<<(ostream& out, const Time& t);
};
```
## (3) UML - диаграмма
<image src ="https://github.com/MishaNyasha/Labs_PSTU_2023/blob/main/Sem_2/Labs/Class_Labs%20/Lab_3/UML_3CL.png">
  
## (4) Тест
<image src ="https://github.com/MishaNyasha/Labs_PSTU_2023/blob/main/Sem_2/Labs/Class_Labs%20/Lab_3/изображение_2024-04-21_151118146.png">

## (5) Ответы на вопросы
**1. Для чего используются дружественные функции и классы?**

`Дружественные функции и классы в C++ используются для предоставления доступа к закрытым (private) членам другого класса.`

`Дружественные функции не являются членами класса, но имеют доступ к его приватным переменным и функциям.`

`Для определения дружественных функций используется ключевое слово friend.`

**2. Сформулировать правила описания и особенности дружественных функций.**

`Дружественные функции могут быть определены внутри класса или в другом классе`.

`Для них не важно, определены ли они под спецификатором public или private`.

`Они имеют доступ ко всем членам класса, включая закрытые.`

**3. Каким образом можно перегрузить унарные операции?**

`Унарные операции могут быть перегружены для пользовательских типов данных (классов).`

`Для перегрузки унарных операций используются специальные методы класса (например, operator+, operator-, operator++, operator--, они были применены в этой лабораторной работе).`

`При перегрузки оператора мы можем заставить его выполнять какие угодно действия над объектом нашего класса`

**4. Сколько операндов должна иметь унарная функция-операция, определяемая внутри класса?**

`Унарная функция-операция, определенная внутри класса, должна иметь от нуля до одного операнда (параметра) в явном виде, так как объект класса в данном случае передаётся неявно, как this.`

**5. Сколько операндов должна иметь унарная функция-операция, определяемая вне класса?**

`Унарная функция-операция, определенная вне класса, должна иметь один операнд в явном виде, так как она не получает this.`

**6. Сколько операндов должна иметь бинарная функция-операция, определяемая внутри класса?**

`Бинарная функция-операция, определенная внутри класса, должна иметь один-два операнда (параметра) в явном виде по причинам, описанным выше.`

**7. Сколько операндов должна иметь бинарная функция-операция, определяемая вне класса?**

`Бинарная функция-операция, определенная вне класса, должна иметь два операнда в явном виде, так как она не получает this.`

**8. Чем отличается перегрузка префиксных и постфиксных унарных операций?**

`Префиксная форма (например, ++x) возвращает измененное значение до выполнения операции.`
`Постфиксная форма (например, x++) возвращает исходное значение, а затем выполняет операцию.`
`При перегрузке постфиксного оператора важно писать в круглых скобках int, например, operator--(int).`

**9. Каким образом можно перегрузить операцию присваивания?**

`Операция присваивания (=) может быть перегружена для пользовательских типов данных. Для этого используется метод operator= внутри класса.`

**10. Что должна возвращать операция присваивания?**

`Операция присваивания (=) должна возвращать ссылку на объект, чтобы обеспечить возможность цепочки присваиваний (например, a = b = c = 42;).`

**11. Каким образом можно перегрузить операции ввода-вывода?**

`Перегрузка операций ввода-вывода в C++ позволяет пользовательским типам данных (классам) определить собственное поведение при вводе и выводе объектов. Для этого используются методы operator>> и operator<<. Для корректной работы перегрузку надо описывать вне класса, как дружественную функцию. Примером использования служит данная лабораторная работа.`

**12. В программе описан класс**
```cpp
class Student
{
	Student& operator++();
};
```
**и определен объект этого класса**
```cpp
Student s;
```
**Выполняется операция**
```cpp
++s;
```
**Каким образом, компилятор будет воспринимать вызов функции-операции?**

`В данном случае, компилятор будет воспринимать вызов функции-операции префиксного инкремента (++s) следующим образом:`

`Оператор ++ будет применяться к объекту s, вызывая метод operator++() внутри класса Student.`

`Метод operator++() должен изменить состояние объекта s и вернуть ссылку на него (тип Student&).`

**13. В программе описан класс**
```cpp
class Student
{
	friend Student& operator ++( Student&);
};
```
**и определен объект этого класса**
```cpp
Student s;
```
**Выполняется операция**
```cpp
++s;
```
**Каким образом, компилятор будет воспринимать вызов функции-операции?**

`Если оператор ++ перегружен как дружественная функция, то компилятор будет воспринимать вызов следующим образом:`

`Оператор ++ будет применяться к объекту s, вызывая дружественную функцию operator++(Student&).`

`Дружественная функция operator++(Student&) также должна изменить состояние объекта s и вернуть ссылку на него.`

14. В программе описан класс
```cpp
class Student
{
	bool operator<(Student &P);
};
```
**и определены объекты этого класса**
```cpp
Student a,b;
```
**Выполняется операция**
```cpp
cout << a < b;
```
**Каким образом, компилятор будет воспринимать вызов функции-операции?**

`В данном случае, компилятор будет воспринимать вызов оператора сравнения следующим образом:`

`Оператор < будет применяться к объектам a и b, вызывая метод operator<(Student&) внутри класса Student.`

`Метод operator<(Student&) должен вернуть true или false в зависимости от результата сравнения.`

`При выводе булевых значений в консоль они выводятся как 0 или 1`

**15. В программе описан класс**
```cpp
class Student
{
	friend bool operator >(const Person&, Person&)
};
```
**и определены объекты этого класса**
```cpp
Student a,b;
```
**Выполняется операция**
```cpp
cout << a > b;
```
**Каким образом, компилятор будет воспринимать вызов функции-операции?**

`Если оператор > перегружен как дружественная функция, то компилятор будет воспринимать вызов следующим образом:`

`Оператор > будет применяться к объектам a и b, вызывая дружественную функцию operator>(const Student&, Student&).`

`Дружественная функция operator>(const Student&, Student&) также должна вернуть true или false.`

`При выводе булевых значений в консоль они выводятся как 0 или 1`
