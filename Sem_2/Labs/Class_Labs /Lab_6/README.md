# Лабораторная работа  No6
# Простое наследование. Принцип подстановки. 

## (1) Задание
1.  Определить класс-контейнер.  
2.  Реализовать конструкторы, деструктор, операции ввода-вывода, операцию присваивания.  
3.  Перегрузить операции, указанные в варианте. 
4.  Реализовать класс-итератор. Реализовать с его помощью операции последовательного доступа. 
5.  Написать тестирующую программу, иллюстрирующую выполнение операций.
## Вариант 1
Класс- контейнер ВЕКТОР с элементами типа int. 
Реализовать операции: 
[] – доступа по индексу; 
() – определение размера вектора; 
+ число – добавляет константу ко всем элементам вектора; 
++ - переход к следующему элементу ( с помощью класса-итератора). 
## (2) Реализация 
- приколюшная main функция:
```cpp
#include <iostream>
#include "Vectort.h"
using namespace std;

int main()
{
    Vector a(5);
    cout << a << "\n";
    cin >> a;
    cout << a << "\n";
    a[2] = 100;
    cout << a << "\n";
    Vector b(10);
    cout << b << "\n";
    b = a;
    cout << b << "\n";
    Vector c(10);
    c = b + 100;
    cout << c << "\n";
    cout << "\nthe length of a=" << a() << endl;
    cout << *(a.first()) << endl;
    Iterator i = a.first();
    i++;
    cout << *i << endl;
    for (i = a.first(); i != a.last(); i++)
        cout << *i << endl;
    return 0;
}
```
- Vector.cpp
```cpp
#include "Vectort.h"

Vector::Vector(int s, int k) 
{
    size = s;
    data = new int[size];
    for (int i = 0; i < size; i++)
        data[i] = k;
    beg.elem = &data[0];
    end.elem = &data[size];
}

Vector::Vector(const Vector& a) 
{
    size = a.size;
    data = new int[size];
    for (int i = 0; i < size; i++)
        data[i] = a.data[i];
    beg = a.beg;
    end = a.end;
}

Vector::~Vector() 
{
    delete[] data;
    data = 0;
}

Vector& Vector::operator=(const Vector& a)
{
    if (this == &a) return *this;
    size = a.size;
    if (data != 0) delete[] data;
    data = new int[size];
    for (int i = 0; i < size; i++)
        data[i] = a.data[i];
    beg = a.beg;
    end = a.end;
    return *this;
}

int& Vector::operator[](int index)
{
    if (index < size) return data[index];
    else  
    {
        cout << "\nError! Index>size";
        return data[0];
    }
}

Vector Vector::operator+(const int k)
{
    Vector temp(size);
    for (int i = 0; i < size; ++i)
        temp.data[i] = data[i] + k;
    return temp;
}

int Vector::operator()()
{
    return size;
}

ostream& operator<<(ostream& out, const Vector& a)
{
    for (int i = 0; i < a.size; ++i)
        out << a.data[i] << " ";
    return out;
}

istream& operator>>(istream& in, Vector& a)
{
    for (int i = 0; i < a.size; ++i)
        in >> a.data[i];
    return in;
}
```
- Vector.h
```cpp
#pragma once
#include <iostream>
using namespace std;

class Iterator
{
	friend class Vector;
public:
	Iterator() { elem = 0; }
	Iterator(const Iterator& it) { elem = it.elem; }
	bool operator==(const Iterator& it) { return elem == it.elem; }
	bool operator!=(const Iterator& it) { return elem != it.elem; };
	void operator++() { ++elem; };
	void operator--() { --elem; }
	int& operator *() const { return *elem; }
private:
	int* elem;
};
class Vector
{
public:
	Vector(int s, int k = 0);
	Vector(const Vector& a);
	~Vector();
	Vector& operator=(const Vector& a);
	int& operator[](int index);
	Vector operator+(const int k);
	int operator()();
	friend ostream& operator<<(ostream& out, const Vector& a);
	friend istream& operator>>(istream& in, Vector& a);
	Iterator first() { return beg; }
	Iterator last() { return end; }
private:
	int size;
	int* data;
	Iterator beg;
	Iterator end;
};
```

## (3) UML - диаграмма
<image src ="https://github.com/MishaNyasha/Labs_PSTU_2023/blob/main/Sem_2/Labs/Class_Labs%20/Lab_6/UML_6CL.png">
  
## (4) Тест
<image src ="https://github.com/MishaNyasha/Labs_PSTU_2023/blob/main/Sem_2/Labs/Class_Labs%20/Lab_5/изображение_2024-04-21_164258936.png">

## (5) Ответы на вопросы
**1. Что такое абстрактный тип данных? Привести примеры АТД.**

`Абстрактный тип данных (АТД) - это математическая модель для типов данных, где тип данных определяется его поведением (семантикой) с точки зрения пользователя данных, в терминах возможных значений, возможных операций над данными этого типа и поведения этих операций. Примеры АТД: стек, очередь, список, множество.`

**2. Привести примеры абстракции через параметризацию.**

`Абстракция через параметризацию позволяет определить структуру, которая может работать с любым типом данных. Примером может служить шаблон класса, где тип данных, с которым должен работать класс, является параметром.`

**3. Привести примеры абстракции через спецификацию.**

`Абстракция через спецификацию включает определение общего интерфейса, который может быть реализован различными способами. Например, интерфейс списка, который может быть реализован как связный список или массив.`

**4. Что такое контейнер? Привести примеры.**

`Контейнер в программировании - это тип, позволяющий инкапсулировать в себе объекты других типов. Примеры контейнеров: vector, list, map.`

**5. Какие группы операций выделяют в контейнерах?**

`В контейнерах выделяют группы операций для добавления, удаления и доступа к элементам, а также операции для работы с размером и состоянием контейнера.`

**6. Какие виды доступа к элементам контейнера существуют? Привести примеры.**

`Произвольный доступ (random access): например, доступ по индексу в массиве или векторе.`
`Последовательный доступ (sequential access): например, перебор элементов с помощью итераторов в списке.`

**7. Что такое итератор?**

`Итератор - это объект, который позволяет перебирать элементы контейнера и предоставляет доступ к каждому элементу в коллекции.`

**8. Каким образом может быть реализован итератор?**

`Итератор может быть реализован как объект с методами для перемещения по контейнеру (например, используя инкрементацию и декрементацию) и получения доступа к элементам. Чтобы понимать границы контейнера, они могут прописываться в нем самом.`

**9. Каким образом можно организовать объединение контейнеров?**

`Объединение контейнеров может быть организовано с помощью создания нового контейнера, который включает в себя элементы исходных контейнеров, также можно сортировать контейнеры при объединении или брать одинаковые элементы только по одному экземпляру, или, вовсе, брать только элементы содержащиеся в обоих изначальных контейнерах. Все зависит от конкретного условия. Для организации удобно использовать перегрузку бинарных операторов.`

**10. Какой доступ к элементам предоставляет контейнер, состоящий из элементов «ключ-значение»?**

`Контейнер, состоящий из элементов «ключ-значение» (например, map), предоставляет доступ к элементам через ключ.`

**11. Как называется контейнер, в котором вставка и удаление элементов выполняется на одном конце контейнера?**

`Контейнер, в котором вставка и удаление элементов выполняется на одном конце, называется стек (stack).`

**12. Какой из объектов (a,b,c,d) является контейнером?**

- a. int mas = 10;
- b. int mas;
- c. struct {char name[30]; int age;} mas;
- d. int mas[100].

`Из предложенных объектов контейнером является d. int mas[100]; - это массив, который может содержать до 100 элементов типа int.`

**13. Какой из объектов (a,b,c,d) не является контейнером?**
- a. int a[] = {1,2,3,4,5};
- b. int mas[30];
- c. struct {char name[30]; int age;} mas[30];
- d. int mas.

`Объект, который не является контейнером: d. 4. int mas; - это объявление переменной без инициализации массива или структуры.`

**14. Контейнер реализован как динамический массив, в нем определена операция доступ по индексу. Каким будет доступ к элементам контейнера?**

`Если контейнер реализован как динамический массив с операцией доступа по индексу, то доступ к элементам будет произвольным.`

**15. Контейнер реализован как линейный список. Каким будет доступ к элементам контейнера?**

`Если контейнер реализован как линейный список, то доступ к элементам будет последовательным.`
